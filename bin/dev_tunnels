#!/usr/bin/env perl

use strict;
use warnings;

use Cwd qw/abs_path cwd getcwd/;
use File::Basename;
use File::Copy;

BEGIN {
    my $abs_path = dirname( dirname ( abs_path( $0 ) ) );
    push @INC, $abs_path . "/lib";
}

use Getopt::Long;
use Necromancer;
use Term::ANSIColor;

my ( 
    $jump_host, $remote_host, $remote_port, 
    $remote_command, $alias, $list, 
    $up, $arg_local_port, $all, $clean,
);

GetOptions ( 
    "jump_host=s"   => \$jump_host,
    "host=s"        => \$remote_host,
    "port=s"        => \$remote_port,
    "alias=s"       => \$alias,
    "list"          => \$list,
    "all"           => \$all,
    "clean"         => \$clean,
    "up=s"          => \$up,
    "local_port=s"  => \$arg_local_port,
);

my $necro = Necromancer->new();
$necro->load_tunnels();

my %local_port = %{ $necro->{ local_port } };

list() if $list;

up() if $up;

if ( !( $jump_host && $remote_port && $remote_host ) ) {
    list();
    exit();
}

$necro->check_host( $jump_host );

my $rand_port;
if ( ! $arg_local_port ) {
    my $count = 0;
    while ( 1 ) {
        $rand_port = (int rand(10000) + 2000 );
        if (! exists $local_port{ $rand_port } ){
            last;
        }
        $count++;
        die "Could not find a free port\n" if $count > 10;
    } 
} else {
    $rand_port = $arg_local_port;
}

fork and exit;

open my $fh, ">>", $necro->{ cfg_dev_tunnels } or die;
    print $fh join "\t", $rand_port, $remote_host, $remote_port, $jump_host, $$, $alias;
    print $fh "\n";
close $fh; 

my $cmd = "ssh -N -L $rand_port\:$remote_host\:$remote_port $jump_host";

print "$$\n";
exec $cmd;


sub load_tunnels {
    open my $fh , "<" , $necro->{ cfg_dev_tunnels } or die "$necro->{ cfg_dev_tunnels }, $!, $@ \n";
        while ( my $line = <$fh> ) {
            chomp $line;
            my ( $local_port, $hostname, $remote_port, $jump_host, $pid, $alias ) = split( /\t/, $line );
            $local_port{ $local_port } = {
                host => $hostname,
                remote_port => $remote_port,
                jump_host => $jump_host,
                pid => $pid,
                alias => $alias || undef,
            };
        }
    close $fh;
}

# Listing does garbage colection

sub list {

        print join "\t", qw/
            jump_host
            port
            hostname
            port
            pid
            alias
        /, "\n";
        
        if ( $clean ) {
            my $append = time();

            move(
                $necro->{ cfg_dev_tunnels }, 
                $necro->{ cfg_dev_tunnels } . $append 
            );
        }

        for my $port ( 
        sort { $local_port{ $a }{ order } <=> $local_port{ $b }{order } 
        } keys %local_port ) {

            if ( ! defined $local_port{ $port } ){
                delete $local_port{ $port };
                next;
            }

            my $status = "\x{2580}";
            my $color;
            $DB::single = 1;
            if ( kill 0, $local_port{ $port }{ pid } ) {
                $color = color( 'rgb141' );
            }else{
                next if ! $all;
                $color = color( 'rgb533' );
                if ( $clean ) {
                    delete $local_port{ $port };
                    next;
                }
            }
            print join "\t", color( 'rgb334' ) .
                             $local_port{ $port }{ jump_host } .
                             $color,
                             $port,
                             sprintf( '%-40.40s', 
                             $local_port{ $port }{ host }
                             ),
                             $local_port{ $port }{ remote_port },
                             $local_port{ $port }{ pid },
                             color( 'reset' ) .
                             ( $local_port{ $port }{ alias } || "" );
            print color( 'reset' );
            print "\n";
            if ( $clean ) {
                update_list( 
                    $port,
                    $local_port{ $port }{ host },
                    $local_port{ $port }{ remote_port },
                    $local_port{ $port }{ jump_host },
                    $local_port{ $port }{ pid },
                    $local_port{ $port }{ alias },
                );
            }
        }
        exit;
}


sub up {
    for my $port ( keys %local_port ) {
        next if $local_port{ $port }{ alias } ne $up;
        fork and exit;
        update_list(
            $port,
            $local_port{ $port }{ host },
            $local_port{ $port }{ remote_port },
            $local_port{ $port }{ jump_host },
            undef,
            $local_port{ $port }{ alias },
        );
        ssh_tunnel( 
            $port,
            $local_port{ $port }{ host },
            $local_port{ $port }{ remote_port },
            $local_port{ $port }{ jump_host },
        );
    }
    die "Could not find the alias $up used before\n";
}


sub ssh_tunnel {
    my ( $local_port, $remote_host, $remote_port, $jump_host ) = @_;

    my $cmd = "ssh -N -L $local_port\:$remote_host\:$remote_port $jump_host";
    exec $cmd;
}

sub update_list {
    my ( $local_port, $remote_host, $remote_port, $jump_host, $pid, $alias ) = @_;

    open my $fh, ">>", $necro->{ cfg_dev_tunnels } or die;
        print $fh 
            join "\t",  $local_port,
                        $remote_host,
                        $remote_port,
                        $jump_host,
                        ( $pid || $$ ),
                        $alias,
                        "\n";
    close $fh; 
}

